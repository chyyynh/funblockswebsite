---
title: "Playerchain 架構"
author: "5p0rt5BEArD"
translateBy: "chiny"
publishedAt: "2024-11-05"
image: "https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6d68d8e4-159e-49e2-b600-bf059b111b03_1229x715.png"
link: "playerchain-architech"
summary: ""
originalLink: "https://5p0rt5beard.substack.com/p/playerchain-architecture"
---

# Playerchain Architecture - by 5p0rt5BEArD Playerchain 架構 - 作者：5p0rt5BEArD

原文連結: https://5p0rt5beard.substack.com/p/playerchain-architecture

Words and Pictures by 5p0rt5BEArD; Architecture by Farms

文字和圖片由 5p0rt5BEArD 提供; 架構由 Farms 提供

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6d68d8e4-159e-49e2-b600-bf059b111b03_1229x715.png)

Playerchain is a game client architecture that incorporates network code for forming peer-to-peer multiplayer sessions that use consensus rather than servers to coordinate. Session consensus is built on immutable histories maintained by each player. These personal blockchains connect in a DAG structure and live on from session to session, enabling player-centric, persistent and interconnected game worlds.

Playerchain 是一種遊戲客戶端架構，包含用於形成點對點多人遊戲工作階段 (Session) 的網路程式，這些會話使用共識而不是伺服器來協調。會話共識建立在每個玩家維護的不可變歷史記錄之上。這些個人區塊鏈以 DAG 結構連接，並在會話之間持續存在，從而實現以玩家為中心、持久且互連的遊戲世界。

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3313b6ab-fca1-4b81-a8a7-433a317598e2_1600x1407.png)

The core elements that make up a playerchain client.

構成 playerchain 客戶端的核心元素。

Game code (the green blocks in the diagram) follows a familiar pattern to existing peer-to-peer multiplayer games: deterministic simulations running on each client with player inputs shared across the network.

遊戲代碼（圖中的綠色塊）遵循與現有點對點多人遊戲熟悉的模式：在每個用戶端上運行的確定性類比，玩家輸入通過網路共用。

Agreeing on the inputs is the job of consensus (the blue blocks in the diagram). As long as all players agree on the order and timing of each others’ inputs, then the game is replicated perfectly for everyone.

就輸入達成一致是共識的工作（圖中的藍色塊）。只要所有玩家都同意彼此輸入的順序和時間，那麼遊戲就可以完美地複製給每個人。

The implementation of the consensus is game specific as long as the core elements are present: single player blockchains joining together to form a blocklace that results in totally ordered inputs. This article focuses on a fast-as-possible-finality approach, but other consensus approaches are possible and there are tradeoffs to be made.

只要核心元素存在，共識的實現就是特定於遊戲的：單人區塊鏈連接在一起形成一個 blocklace，從而產生完全有序的輸入。本文重點介紹一種盡可能快的確定性方法，但其他共識方法也是可能的，並且需要做出權衡。

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa8e989ff-d4bf-459e-99dc-33e59ad4ebeb_1600x900.png)

Our Playerchain Demo [8] demands fast consensus. Play and view source on github.

我們的 Playerchain 演示 [8] 需要快速達成共識。在 github 上播放和查看原始程式碼。

Game genres like a space shooter, require fast-as-possible-finality because players must react to each other's moves quickly and corrections of moves have a large effect on the players’ world view. We chose a space shooter for our demo application, so we could show a playerchain working with the most demanding game type.

像太空射擊遊戲這樣的遊戲類型需要盡可能快的結局，因為玩家必須對彼此的動作做出快速反應，而對動作的修正對玩家的世界觀有很大影響。我們為演示應用程式選擇了太空射擊遊戲，這樣我們就可以展示一個處理最苛刻遊戲類型的玩家鏈。

Anyone can create a playerchain but access to the playerchain is controlled by the group.

任何人都可以創建 playerchain，但對 playerchain 的訪問由組控制。

Before a playerchain session begins, peers must find each other and share a key that ensures their group is private. Fast consensus relies on a known fixed group, rather than the time or money-based security that slows down consensus on a permissionless chain.

在 playerchain 工作階段開始之前，對等節點必須找到彼此並共用一個密鑰，以確保他們的組是私有的。快速共識依賴於已知的固定組，而不是基於時間或金錢的安全性，這會減慢無許可鏈上的共識。

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd9f461a0-c5d6-469a-bfa0-78a1c5c7397e_1535x924.png)

Each input is included in its own block structure that references the previous block by its hash, thus forming an immutable blockchain of this player’s inputs. For our fast finality approach, a block is created every tick, so blocks must also indicate if no input was made. This allows other players to know the difference between waiting for an input and there being no input to wait for.

每個輸入都包含在自己的區塊結構中，該結構通過其哈希值引用前一個區塊，從而形成該玩家輸入的不可變區塊鏈。對於我們的快速確定性方法，每個 tick 都會創建一個區塊，因此區塊還必須指示是否沒有輸入。這允許其他玩家知道等待輸入和沒有輸入可等待之間的區別。

The DAG structure formed in a playerchain is a blocklace [1]; a type of CRDT that is suitable for applying multiple types of consensus. The Cordial Miners [2] protocol presents various algorithms for consensus on a blocklace.

玩家鏈中形成的 DAG 結構是一個 blocklace [1];一種適合應用多種類型共識的 CRDT。Cordial Miners [2] 協定提出了各種演算法，用於在 blocklace 上達成共識。

Each player shares their own blockchain by sending signed messages containing their latest block to all the peers in the current playerchain group.

每個玩家通過向當前 playerchain 組中的所有對等節點發送包含其最新區塊的簽名消息來共用自己的區塊鏈。

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6e7aef5d-6f86-44b6-b00c-bba8ed787c29_1599x809.png)

Players combined their own chain with those being shared by remote players.

玩家將自己的鏈與遠端玩家共用的鏈組合在一起。

As players share their own blockchains they also share references to each other's blocks. Following the dissemination algorithm laid out in the Cordial Miners [2] paper, a blocklace structure is formed. Blocks are grouped in rounds where a new block cannot be started until blocks from two thirds of peers have been received for the current round.

當玩家共用自己的區塊鏈時，他們也會共用對彼此區塊的引用。按照 Cordial Miners [2] 論文中提出的傳播演算法，形成了一個 blocklace 結構。區塊被分組為輪次，在當前輪次收到來自三分之二的 Peer 節點的區塊之前，無法啟動新區塊。

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa9a6e699-b17a-4c57-8990-6175a926fcda_1600x1316.png)

Game specific blocklace formation matches DAG rounds to game ticks.

遊戲特定的 blocklace 形成將 DAG 回合與遊戲 tick 匹配。

For the purposes of a fast-as-possible-finality game for a playerchain, each round can be considered to match a simulation tick of the game. Therefore each round contains either the input or an explicit “no input” for each player at a specific game frame.

為了實現 playerchain 的快速確定性遊戲，可以認為每一輪都與遊戲的類比 tick 匹配。因此，每一輪都包含特定遊戲幀中每個玩家的輸入或顯式“無輸入”。

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1a7c07a0-a493-4ac1-8e73-8e33e6f6911e_1600x908.png)

Playerchains can pre-determine total order to speed things up.

Playerchains 可以預先確定總順序以加快速度。

By matching blocklace rounds to ticks, clients can add a tick number to their blocks. Combined with a deterministic player order, each block effectively has a predetermined total order. This is not typical in distributed consensus where total order requires further inputs to be able to algorithmically finalise the block’s order. For the blocklace this could be done with the Tau ordering algorithm from Cordial Miners [2] which is optimised to reduce the rounds required for finality yet will always add more time compared to pre-ordering.

通過將 blocklace rounds 與 tick 匹配，客戶可以向他們的區塊添加 tick 編號。結合確定性的玩家順序，每個區塊實際上都有一個預定的總順序。這在分散式共識中並不常見，其中總順序需要進一步的輸入才能通過演算法最終確定區塊的順序。對於 blocklace，這可以通過 Cordial Miners [2] 的 Tau 排序演算法來完成，該演算法經過優化以減少最終確定性所需的回合數，但與預購相比，它總是會增加更多時間。

Pre-ordering assumes the typical case of honest clients and allows a game to show inputs as soon as they are received, rather than waiting for further inputs to algorithmically confirm the order. Dishonest attacks by equivocating (telling two peers two different inputs) or declaring an input for a much older tick will result in re-simulations but the game will remain consistent.

預訂購假設誠實用戶端的典型情況，並允許遊戲在收到輸入后立即顯示輸入，而不是等待進一步的輸入來通過演算法確認順序。通過模棱兩可（告訴兩個對等體兩個不同的輸入）或聲明更舊的 tick 的輸入來進行不誠實的攻擊將導致重新類比，但遊戲將保持一致。

There are established techniques [3][4][5][6], like prediction and rollback for ensuring a good playing experience with input-based multiplayer games. Predicting remote players’ inputs before they arrive allows games to continue without having to wait for network latency. The logic simulation runs on, mixing the local players actual inputs with the predicted ones for remote players. When remote player inputs arrive that are different to the predictions, the simulation is rolled back to a state before those inputs and replayed with the correct inputs. The time into the past for which predicted inputs are allowed to be corrected is the “rollback window”.

有一些成熟的技術 [3][4][5][6]，例如預測和回滾，用於確保基於輸入的多人遊戲獲得良好的遊戲體驗。在遠端玩家到達之前預測他們的輸入，使遊戲可以繼續進行，而無需等待網路延遲。邏輯類比繼續運行，將本地玩家的實際輸入與遠端玩家的預測輸入混合在一起。當遠端玩家輸入到達時，與預測不同的輸入，類比將回滾到這些輸入之前的狀態，並使用正確的輸入重播。允許更正預測輸入的過去時間是 「回滾視窗」。

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9f454bb8-9db0-4e2f-8204-9795db0b3411_1200x670.png)

The netcode article on Fightin’ Words [4] is an excellent walk through of prediction and rollback as used in a beat-em-up

關於 Fightin' Words [4] 的 netcode 文章是 Beat-em 中使用的預測和回滾的優秀演練

Re-simulations after a rollback happen in a single render frame. If the new inputs did not affect the local player they may not notice. If the new inputs cause state changes that affect the local player they may see game entities suddenly move, disappear or appear.

回滾后的重新模擬發生在單個渲染幀中。如果新輸入不會影響本地玩家，他們可能不會注意到。如果新輸入導致影響本地玩家的狀態更改，他們可能會看到遊戲實體突然移動、消失或出現。

These side effects are more onerous in games where:

這些副作用在以下遊戲中更為繁重：

Players are likely to be interacting with each other;

玩家可能會相互交互;

Predictions are hard to make;

預測很難做出;

Small input changes have a dramatic effect on future state.

微小的 input 更改對 future state 有顯著影響。

(All of these are characteristics of a space shooter).

（所有這些都是太空射擊遊戲的特徵）。

Re-simulations can be reduced by limiting the rollback window. But if the rollback window time is reached and not all inputs have arrived, a game must either pause or continue and then ignore any late arriving inputs.

可以通過限制回滾視窗來減少重新模擬。但是，如果已達到回滾窗口時間，但並非所有輸入都已到達，則遊戲必須暫停或繼續，然後忽略任何延遲到達的輸入。

Prediction and rollback may be handled by a relay in a server-supported network but in a playerchain, it must be handled by consensus. The size of the rollback window, the decision to pause and which inputs to drop must be done predictably. Different algorithms could be used for different games. Below we step through the algorithm for fast-as-possible-finality consensus developed for the space shooter game:

預測和回滾可以由伺服器支援的網路中的中繼處理，但在玩家鏈中，它必須由共識處理。回滾視窗的大小、暫停的決定以及要刪除的輸入必須以可預測的方式完成。不同的演算法可以用於不同的遊戲。下面我們逐步介紹為太空射擊遊戲開發的盡可能快的最終確定性共識演算法：

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F31994b93-5756-4a48-a448-a33d3f7a5185_1534x474.png)

Key for the round diagrams below

下面圓圖的關鍵

Round 0. Group Formation

第 0 輪。組隊組建

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F58c85e07-4357-4393-9eac-377598fcb07e_1600x815.png)

All clients are deterministically assigned a player index on group formation and can therefore predict the total order of each of their future blocks.

所有用戶端在組形成時都被確定性地分配了一個玩家索引，因此可以預測他們未來每個區塊的總順序。

Round 1. Wait for consensus

第 1 輪。等待共識

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F21fa09c1-1829-4302-ac33-ef908db534b5_1600x815.png)

We, the local player, have made an input but not received any others. No further blocks can be produced until at least one other player input is received. (See tuning below to see how the likelihood of this pause is reduced) .

我們（本地玩家）已提出意見，但未收到任何其他意見。在收到至少一個其他玩家輸入之前，不能生成更多的區塊。（請參閱下面的調整以瞭解如何降低此暫停的可能性）。

Round 2. Proceed with prediction

第 2 輪。繼續進行預測

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F27d3ebbd-41e9-4454-949b-194758bfca88_1600x815.png)

We have received the round 1 input for “remote 1”. This achieves the two-thirds majority needed to proceed and process our round 2 block. Note how any unreceived blocks must be predicted (dotted lines) and in this case are predicted to be “no input”.

我們已收到“remote 1”的第 1 輪輸入。這實現了繼續和處理我們的第 2 輪區塊所需的三分之二多數。請注意必須如何預測任何未接收的塊（虛線），在這種情況下，預測為 “no input”。

Round 3. Rollback

第 3 輪。反轉

We have received the round 2 input for “remote 1” and it is an input we didn’t predict. The game is rewound and re-simulated from round 2 before our next rendered frame.

我們收到了“remote 1”的第 2 輪輸入，這是我們沒有預料到的輸入。遊戲從第 2 輪開始倒帶並重新模擬，然後我們渲染下一個幀。

Round 4. Finality

第 4 輪。終局

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F20fba077-ba32-49d5-977c-a9fe5d01d13b_1600x815.png)

Locally we have progressed to round 4 because we have two-thirds of the blocks for round 3. Now round 1 has been finalised because we have enough round 1 inputs acknowledged by our last round. Any future blocks received for round 1 will be ignored.

在本地，我們已經晉級到第 4 輪，因為我們有三分之二的區塊進入第 3 輪。現在第 1 輪已經完成，因為我們有足夠的第 1 輪輸入被上一輪確認。第 1 輪收到的任何未來區塊都將被忽略。

Round 5. Dropped Inputs

第 5 輪。丟棄的輸入

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F31364534-d4cf-48aa-9182-c55f48f9ec22_1600x815.png)

We have finally received some inputs from remote 2. The inputs for round 1 and 2 are ignored because they missed the rollback window. This will be the case on all clients including the remote 2 client itself, which will drop its own inputs and re-simulate to remain in sync.

我們終於收到了來自 remote 2 的一些輸入。第 1 輪和第 2 輪的輸入被忽略，因為它們錯過了回滾視窗。所有用戶端（包括 remote 2 用戶端本身）都是這種情況，它將丟棄自己的輸入並重新模擬以保持同步。

Each peer tries to send a new block at the target game tick rates so the effect of following the steps above, as long as all peers are receiving all remote inputs within two ticks of each other, then the game runs at target frame rate for everyone. That is a tight constraint on the network so some game-specific tuning is needed of a few elements but in particular getting the best sized rollback window.

每個對等體都嘗試以目標遊戲節拍率發送新區塊，因此遵循上述步驟的效果是，只要所有對等體都在彼此的兩個節拍內接收到所有遠端輸入，那麼遊戲就會以目標幀速率運行。這是對網路的嚴格限制，因此需要對一些元素進行一些特定於遊戲的調整，但特別是要獲得最佳大小的回滾視窗。

Balancing the rollback window is a crucial part in tuning the user experience with prediction and rollback. If the rollback window is too short and less than a third of players are lagging behind, the laggers will get their inputs dropped and have a bad experience. If more than a third are lagging behind, everyone else will have a paused game while they wait for at least two thirds to catch up. If the window is too large then remote inputs that differ from predictions have more chance of causing a jerky view for everyone. Balancing the window must be done with many other factors in mind and is not unique to a playerchain. However, increasing the rollback window in the blocklace is a new problem, which we solve with interlacing sets of rounds:

平衡回滾視窗是通過預測和回滾來優化用戶體驗的關鍵部分。如果回滾視窗太短，並且只有不到三分之一的玩家落後，則落後者的輸入將被丟棄，並獲得糟糕的體驗。如果超過三分之一的玩家落後，則其他人都將暫停遊戲，同時等待至少三分之二的玩家趕上。如果視窗太大，則與預測不同的遠端輸入更有可能給每個人帶來不穩定的視圖。平衡窗口必須考慮許多其他因素，這並不是 playerchain 獨有的。然而，增加 blocklace 中的回滾視窗是一個新問題，我們通過交錯輪次集來解決：

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F8688be38-3c0a-4ad2-b9ed-e2fc4e2a3c66_1600x997.png)

Introducing sets to blocklace formation to increase the rollback window.

引入 sets 到 blocklace formation 以增加回滾視窗。

The blocklace dissemination algorithm requires rounds to progress evenly by requiring each peer to wait for two thirds of the previous round to be seen before making a new block. This equates to a small, two frame rollback window.

blocklace 傳播演算法要求每個 Peer 節點在創建新區塊之前等待前一輪的三分之二被看到，從而要求輪次均勻進行。這相當於一個小的雙幀回滾視窗。

The rollback window can be increased by increasing the number of rounds each local client can go ahead but the algorithm requires blocks to wait on references from the previous round. We enable processing further ahead by introducing interlaced sets of rounds. While one set is waiting the next set can continue until we run out of sets (see above diagram).

可以通過增加每個本地用戶端可以進行的輪數來增加回滾視窗，但該演算法需要塊等待上一輪的引用。我們通過引入交錯輪次集來支援更進一步的處理。當一個 set 正在等待時，下一個 set 可以繼續，直到我們用完 sets（見上圖）。

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd7e3b525-5d50-4a4b-a3a6-7b9b81842e63_1600x848.png)

The blocklace formation, using Cordial Miners dissemination, does not require waiting for message acknowledgements, so peers can send blocks unbounded by latency and games can operate at a tick rate higher than latency. Rather than waiting for an acknowledgment of the last message, each new input is combined with references to the latest known inputs of other peers that act as acknowledgements.

使用 Cordial Miners 傳播的 blocklace 形成不需要等待消息確認，因此 Peer 節點可以發送不受延遲限制的區塊，並且遊戲可以以高於延遲的滴答率運行。不是等待最後一條消息的確認，而是每個新 Importing 都與對其他 Peer 節點的最新已知 Importing 的引用相結合，這些 Importing 充當確認。

Matching message rounds with game ticks and targeting a fixed frame rate allows any tick rate to be targeted including 30 or even 60 ticks per second. At these rates, poor network conditions cause the rollback window to be frequently breached and therefore a poor user experience as some player inputs are dropped or the game is paused. So for the playerchain demo game, which is designed to run in ad-hoc network environments, we set a tick rate of 10 ticks per second (note that rendering will typically be 60fps).

將消息回合與遊戲時鐘週期匹配並瞄準固定幀速率，允許以任何時鐘週期率為目標，包括每秒 30 甚至 60 個時鐘週期。在這些速率下，糟糕的網路條件會導致回滾視窗經常被突破，因此，當某些玩家輸入被丟棄或遊戲暫停時，用戶體驗會很差。因此，對於設計為在 ad-hoc 網路環境中運行的 playerchain 演示遊戲，我們將滴答速率設置為每秒 10 滴答（請注意，渲染通常為 60fps）。

The Playerchain Demo project focuses on demonstrating fast-as-possible consensus for a responsive multiplayer session. The Tashi consensus network [9] implements a similar architecture (DAG consensus over realtime game inputs) as an ephemeral side-chain. As a side-chain, verifiable sessions can connect to public blockchains, which is also true for a playerchain session. The vision for playerchains is that they can also persist and connect in their own right, which is a reason for choosing the blocklace structure.

Playerchain Demo 項目側重於演示回應式多人遊戲會話的快速共識。Tashi 共識網路 [9] 實現了類似的架構（即時遊戲輸入上的 DAG 共識）作為臨時側鏈。作為側鏈，可驗證會話可以連接到公共區塊鏈，玩家鏈會話也是如此。playerchains 的願景是它們也可以獨立存在和連接，這就是選擇 blocklace 結構的一個原因。

In the playerchain demo [8], each session creates a new key pair for each player that is discarded at the end, along with any record of the blockchain. By introducing a player identity that persists between games, the blockchains of each player and their last session interactions can also be persisted. As players join new groups and play new games, a global blocklace is formed with each player having a partial view that tracks their progress.

在 playerchain 演示 [8] 中，每個會話都會為每個玩家創建一個新的密鑰對，該密鑰對在最後被丟棄，以及區塊鏈的任何記錄。通過引入在遊戲之間持續存在的玩家身份，每個玩家的區塊鏈及其上次會話交互也可以持久化。當玩家加入新組並玩新遊戲時，會形成一個全域 blocklace，每個玩家都有一個跟蹤其進度的部分視圖。

![Image](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F47dcd00a-58b6-40b3-9ee5-d1d17b66e616_1600x1082.png)

The coloured patches represent playerchains; Partial views of a global blocklace that groups have agreed to progress together while playing a game.

彩色補丁表示玩家鏈;組同意在玩遊戲時共同進步的全域 blocklace 的部分檢視。

Practically, a global blocklace of all player histories across all games runs into storage issues and time limits for restoring state from an ever growing history. These are well tackled issues in the world of blockchain with techniques like provable state checkpoints and content addressable storage but there is work to do to make the global blocklace a practical reality.

實際上，所有遊戲中所有玩家歷史記錄的全域阻塞會遇到存儲問題和從不斷增長的歷史記錄中恢復狀態的時間限制。這些都是區塊鏈世界中使用可證明狀態檢查點和內容可尋址存儲等技術很好地解決的問題，但要使全球 blocklace 成為現實，還有工作要做。

With a global blocklace, trust is built up between players and groups as they share more interactions. An example would be two playerchain worlds from the same game agreeing to trade resources because they can verify each other's partial view of the blocklace. Unlike the public blockchain version of state, no monolithic public view exists. The global state emerges from the many partial, player-centric, views.

通過全域 blocklace，玩家和群組之間會建立信任，因為他們共用更多的交互。一個例子是來自同一遊戲的兩個 playerchain 世界同意交易資源，因為它們可以驗證彼此對 blocklace 的部分檢視。與公共區塊鏈版本的狀態不同，不存在單一的公共視圖。全域狀態從許多片面的、以玩家為中心的觀點中出現。

The architecture presented allows multiplayer games to run without third party infrastructure. That could be useful from a cost or ease of maintenance point of view. However, the main reason Playmint have developed playerchains is for making decentralised games that are for playing, not speculating. You can read more about our motivations here [7].

所介紹的架構允許多人遊戲在沒有第三方基礎設施的情況下運行。從成本或易於維護的角度來看，這可能很有用。然而，Playmint 開發 playerchains 的主要原因是為了製作用於玩而不是投機的去中心化遊戲。您可以在此處閱讀有關我們動機的更多資訊 [7]。

[1] The Blocklace: A Universal, Byzantine Fault-Tolerant, Conflict-free Replicated Data Type; Paulo Sérgio Almeida, Ehud Shapiro

[1] Blocklace：一種通用的、拜占庭式的容錯、無衝突的複製數據類型;保羅·塞爾吉奧·阿爾梅達， 埃胡德·夏皮羅

[2] Cordial Miners: Fast and Efficient Consensus for Every Eventuality; Idit Keidar, Oded Naor, Ouri Poupko, Ehud Shapiro;

[2] Cordial Miners：為每一種可能性提供快速高效的共識;伊迪特·凱達爾、奧德·瑙爾、奧里·波普科、埃胡德·夏皮羅;

[3] Photon Engine’s Quantum; Exit Games

[3] Photon Engine 的 Quantum;退出遊戲

[4] Netcode: Explaining how fighting games use delay-based and rollback netcode; Infil, Fightin’ Words

[4] 網络代碼：解釋格鬥遊戲如何使用基於延遲和回滾的網络代碼;Infil, Fightin’ Words

[5] 1500 Archers on a 28.8: Network Programming in Age of Empires and Beyond; Paul Bettner

[5] 1500 Archers on a 28.8：帝國時代及以後的網络程式設計;保羅·貝特納

[6] GGPO; Rollback Network SDK; pond3r

[6] GGPO;回滾網路 SDK;池塘 3r

[7] Why We Need Playerchains; 5p0rt5BEArD

[7] 為什麼我們需要 Playerchains;5p0rt5BEArD

[8] Playerchain Demo; Playmint team

[8] Playerchain 演示;Playmint 團隊

[9] Tashi Protocol: A viable consensus engine for multiplayer games; Bobby Bhatia, Ken Anderson, Steve Marshall, Sean Tedrow, Austin Bonander

[9] Tashi Protocol：多人遊戲的可行共識引擎;鮑比·巴蒂亞、肯·安德森、史蒂夫·馬歇爾、肖恩·泰德羅、奧斯丁·博南德

![Image](https://substackcdn.com/image/fetch/w_64,h_64,c_fill,f_auto,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack.com%2Fimg%2Favatars%2Flogged-out.png)

No posts

無帖子

Ready for more?

準備好更多了嗎？
